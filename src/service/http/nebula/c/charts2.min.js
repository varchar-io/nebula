import{Flame}from"./flame.min.js";import{Color}from"./color.min.js";const pad2=v=>`${v}`.padStart(2,0),isTime=c=>"_time_"===c,windowKey="_window_",autoKey=c=>isTime(c)||c==windowKey;export class Charts{constructor(){this.id="viz",this.chart=null,this.cls=chartId=>$(chartId).html(`<canvas id='${this.id}' height='100pt'/>`),this.formatTime=unix_ms=>{const date=new Date(unix_ms),y=date.getUTCFullYear(),m=pad2(date.getUTCMonth()+1),d=pad2(date.getUTCDate()),h=pad2(date.getUTCHours()),mi=pad2(date.getUTCMinutes()),s=pad2(date.getUTCSeconds());return`${y}-${m}-${d} ${h}:${mi}:${s}`},this.displayTable=(chartId,json,keys,metrics)=>{if(json.length>0){const area=$(chartId);area.html("");const tb=$("<table/>").appendTo(area),head=$("<tr/>").appendTo($("<thead/>").appendTo(tb)),content=$("<tbody/>").appendTo(tb),included=[...keys,...metrics],cols=Object.keys(json[0]).filter(e=>e==autoKey(e)||included.includes(e)),width=Math.round(100/cols.length);cols.forEach(k=>$("<th/>").appendTo(head).attr("width",`${width}%`).text(autoKey(k)?"[time]":k)),json.forEach(row=>{const r=$("<tr/>").appendTo(content);cols.forEach(k=>{const v=row[k];$("<td/>").appendTo(r).text(isTime(k)?this.formatTime(1e3*v):v)})})}},this.hyphen=" - ",this.label=(row,keys)=>{const kv=[];return keys.forEach(k=>{kv.push(`${row[k]}`)}),kv.join(this.hyphen)},this.process=(json,keys,metrics,x,xf)=>{let genLabel=row=>this.label(row,keys),genSeries=row=>"",desc=keys.length>0?`metrics by ${keys.join(this.hyphen)}`:null;x&&(desc=`metrics by ${x==windowKey?"timeline":x}`,genSeries=genLabel,genLabel=row=>xf(row[x]));const align=(vector,size,filling)=>{const val=filling||0;for(;vector.length<size;)vector.push(val)},buckets=[],set={},genSet=row=>{const x=genLabel(row);let index=-1;for(var i=0;i<buckets.length;++i)if(x===buckets[i]){index=i;break}-1==index&&(index=buckets.length,buckets.push(x));const name=genSeries(row),series=name?[name]:metrics;for(var i=0;i<series.length;++i){const s=series[i];s in set||(set[s]=[]);const data=set[s];align(data,index+1),data[index]=+row[metrics[i]]}};json.forEach(row=>genSet(row));for(const key in set){const vector=set[key];align(vector,buckets.length)}return{title:desc,labels:buckets,series:set}},this.options=model=>{const opts={responsive:!0,hover:{animationDuration:0},responsiveAnimationDuration:0,title:{display:model.title,text:model.title},legend:{display:!0,labels:{fontColor:"rgba(147, 112, 219, 0.75)"}},tooltips:{mode:"index",intersect:!1,callbacks:{label:(item,data)=>{const ds=data.datasets[item.datasetIndex];var label=ds.label||"";label&&(label+=": ");const val=`${ds.data[item.index]}`;if(label+=val,model.pct){var total=ds.data.reduce((prev,cur,curIdx,arr)=>prev+cur);label+=`, ${Math.floor(val/total*100+.5)}%`}return label}}},scales:{yAxes:[{ticks:{beginAtZero:!0}}],xAxes:[{ticks:{beginAtZero:!0}}]}};if("pie"!==model.type&&"doughnut"!==model.type||(opts.scales.yAxes=[],opts.scales.xAxes=[]),model.xtime){const l=model.labels;let u="year";const S=60,M=3600,H=24*M,D=30*H,Y=365*D;if(l.length>1){const delta=(new Date(l[1]).getTime()-new Date(l[0]).getTime())/1e3;delta<S?u="second":delta<M?u="minute":delta<H?u="hour":delta<D?u="day":delta<Y&&(u="month")}opts.scales.xAxes=[{type:"time",distribution:"series",ticks:{autoSkip:!0,autoSkipPaddding:75,maxTicksLimit:15,maxRotation:0,minRotation:0},time:{unit:u,displayFormats:{second:"HH:mm:ss",minute:"HH:mm",hour:"HH:mm",day:"MMM DD",month:"MM/YY",year:"YY"}}}]}return opts},this.displayGeneric=(chartId,model,bg,fil,multiple=!1)=>{const dataset={labels:model.labels,datasets:[]};let idx=0;for(const name in model.series){const d={label:name,fill:fil||!1,pointRadius:0,data:model.series[name]};d[bg?"backgroundColor":"borderColor"]=Color.get(idx++),dataset.datasets.push(d)}if(1==idx&&!model.xtime){const single=dataset.datasets[0],colors=[];single.data.forEach(()=>{colors.push(Color.get(idx++))}),single.backgroundColor=colors}this.chart&&!multiple&&this.chart.destroy(),this.chart=new Chart(chartId,{type:model.type,data:dataset,options:this.options(model)})},this.displayBar=(chartId,json,keys,metrics,vertical,multiple=!1)=>{if(this.cls(chartId),multiple){let i=0;const area=$(chartId);area.html(""),metrics.forEach(metric=>{const title=this.label(json[i],keys);for(var k in metric){const model=this.process([json[i][k]],keys,metric[k]),id=`bar_${i++}`;area.append(`<center>${title}</center>`),area.append(`<canvas id='${id}' width='${area.width()}'/>`),model.type=vertical?"bar":"horizontalBar",this.displayGeneric(id,model,!0,null,!0)}})}else{const model=this.process(json,keys,metrics);model.type=vertical?"bar":"horizontalBar",this.displayGeneric(this.id,model,!0)}},this.displayLine=(chartId,json,keys,metrics)=>{this.cls(chartId);const model=this.process(json,keys,metrics);model.type="line",this.displayGeneric(this.id,model,!1)},this.displayPie=(chartId,json,keys,metrics,doughnut)=>{this.cls(chartId);const model=this.process(json,keys,metrics);model.pct=!0,model.type=doughnut?"doughnut":"pie",this.displayGeneric(this.id,model,!0)},this.displayTimeline=(chartId,json,keys,metrics,timeCol,start,mode)=>{this.cls(chartId);const model=this.process(json,keys,metrics,timeCol,x=>this.formatTime(1e3*x+start));model.xtime=!0,model.type=2==mode?"bar":"line",this.displayGeneric(this.id,model,mode,1==mode)},this.displayFlame=(chartId,json,keys,metrics,flame)=>{if(1!==metrics.length||!metrics[0].endsWith(".TREEMERGE"))return"Flame view supports only single metric resulting by treemerge function";const area=$(chartId);area.html("");let i=0;json.forEach(row=>{const title=this.label(row,keys),stack=row[metrics[0]],id=`fg_${i++}`;area.append(`<center>${title}</center>`),area.append(`<canvas id='${id}' width='${area.width()}'/>`),new Flame(id,JSON.parse(stack),flame)})}}}