import{neb}from"../dist/web/main2.js";import{State}from"./state.min.js";let isType=(a,b)=>typeof a===b,isNumber=a=>isType(a,"number"),isString=a=>isType(a,"string"),isFunction=a=>isType(a,"function"),s=a=>a.map(a=>`${a}`),log=console.log,except=a=>{throw{message:a}},CT=neb.CustomType,OT=neb.OrderType,RU=neb.Rollup,OP=neb.Operation;export class Nebula{constructor(){this.Type={INT:CT.INT,LONG:CT.LONG,FLOAT:CT.FLOAT,DOUBLE:CT.DOUBLE,STRING:CT.STRING},this.Sort={ASC:OT.ASC,DESC:OT.DESC,NONE:OT.NONE},this.reset=()=>{this.src_="",this.keys_=[],this.metrics_=[],this.start_=0,this.end_=0,this.columns_=[],this.timeline_=!1,this.time_unit_=0,this.sort_=this.Sort.ASC,this.limit_=100,this.filter_={},this.pivot_="",this.map_=null,this.rm_=[],this.window_=0},this.source=a=>(this.src_=a,this),this.time=(a,b)=>(this.start_=a,this.end_=b,this),this.select=(...args)=>{for(var i=0;i<args.length;++i){let arg=args[i],type=typeof arg;if("string"===type)this.keys_.push(arg);else if("function"===type)this.metrics_.push(eval(arg));else if("object"===type)this.metrics_.push(arg);else throw`Unsupported field type: ${type}.`}return this},this.pivot=a=>(this.keys_.includes(a)&&1===this.metrics_.length||except("pivot existing key for single metric."),this.pivot_=a,this),this.map=(a,...b)=>(this.map_=a?`() => ${a.toString()};`:"",this.rm_=b,this),this.where=a=>(a&&(a.l?this.filter_=a:this.filter_={l:"AND",r:[a]}),this),this.sortby=a=>(this.sort_=a,this),this.limit=a=>(this.limit_=a,this),this.apply=(b,a,c)=>(b&&isString(b)||except("apply - column name required"),(void 0===a||!isNumber(a)||a<this.Type.INT||a>this.Type.STRING)&&except("apply - unsupported type."),c&&isFunction(c)||except("apply - lambda/function required."),this.columns_.push({name:b,type:a,expr:`const ${b} = ${c.toString()};`}),this),this.run=(a,b)=>(this.timeline_=!!a,this.window_=b||0,this),this.timeline=a=>this.run(!0,a),this.validate=()=>this.src_?0===this.start_||0===this.end_?(log(`Invalid time range [${this.start_}, ${this.end_}].`),"Invalid time range."):0===this.keys_.length&&0===this.metrics_.length?"Keys or metrics missing":this.limit_<1?(log(`Invalid limit: ${this.limit_}`),"Invalid limit value."):this.sort_!=this.Sort.ASC&&this.sort_!=this.Sort.DESC&&this.sort_!=this.Sort.NONE?(log(`Invalid sort value: ${this.sort_}`),"Invalid sort option."):null:"Invalid table source.",this.build=()=>{let b=new State,a=b.state_;return a.table=this.src_,a.start=this.start_,a.end=this.end_,a.keys=this.keys_,a.window=this.window_,a.timeline=this.timeline_,a.time_unit=this.time_unit_,a.limit=this.limit_,a.sort=this.sort_,a.metrics=this.metrics_,a.filter=this.filter_,a.customs=this.columns_,q,a.pivot=this.pivot_,a.map=this.map_,a.rm=this.rm_,a}}}export const count=a=>({M:RU.COUNT,C:a,A:a,as:function(a){return this.A=a,this}});export const sum=a=>({M:RU.SUM,C:a,A:a,as:function(a){return this.A=a,this}});export const max=a=>({M:RU.MAX,C:a,A:a,as:function(a){return this.A=a,this}});export const min=a=>({M:RU.MIN,C:a,A:a,as:function(a){return this.A=a,this}});export const avg=a=>({M:RU.AVG,C:a,A:a,as:function(a){return this.A=a,this}});export const tree=a=>({M:RU.TREEMERGE,C:a,A:a,as:function(a){return this.A=a,this}});export const p10=a=>({M:RU.P10,C:a,A:a,as:function(a){return this.A=a,this}});export const p25=a=>({M:RU.P25,C:a,A:a,as:function(a){return this.A=a,this}});export const p50=a=>({M:RU.P50,C:a,A:a,as:function(a){return this.A=a,this}});export const p75=a=>({M:RU.P75,C:a,A:a,as:function(a){return this.A=a,this}});export const p90=a=>({M:RU.P90,C:a,A:a,as:function(a){return this.A=a,this}});export const p99=a=>({M:RU.P99,C:a,A:a,as:function(a){return this.A=a,this}});export const p99_9=a=>({M:RU.P99_9,C:a,A:a,as:function(a){return this.A=a,this}});export const p99_99=a=>({M:RU.P99_99,C:a,A:a,as:function(a){return this.A=a,this}});export const and=(...a)=>0==a.length?{}:{l:"AND",r:a};export const or=(...a)=>0==a.length?{}:{l:"OR",r:a};export const eq=(b,...a)=>(0==a.length&&except("syntax: eq(<column>, val1, val2, ...)"),{c:b,o:OP.EQ,v:s(a)});export const neq=(b,...a)=>(0==a.length&&except("syntax: eq(<column>, val1, val2, ...)"),{c:b,o:OP.NEQ,v:s(a)});export const gt=(a,b)=>({c:a,o:OP.MORE,v:s([b])});export const lt=(a,b)=>({c:a,o:OP.LESS,v:s([b])});export const like=(a,b)=>({c:a,o:OP.LIKE,v:s([b])});export const ilike=(a,b)=>({c:a,o:OP.ILIKE,v:s([b])});export const unlike=(a,b)=>({c:a,o:OP.UNLIKE,v:s([b])});export const iunlike=(a,b)=>({c:a,o:OP.IUNLIKE,v:s([b])})