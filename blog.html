<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Nebula Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Nebula Blog Atom Feed"><title data-react-helmet="true">Blog | Nebula</title><meta data-react-helmet="true" property="og:title" content="Blog | Nebula"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="description" content="Blog"><meta data-react-helmet="true" property="og:description" content="Blog"><meta data-react-helmet="true" property="og:url" content="https://varchar-io.github.io/blog"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="blog_posts_list"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://varchar-io.github.io/blog"><link data-react-helmet="true" rel="alternate" href="https://varchar-io.github.io/blog" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://varchar-io.github.io/blog" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.ca62a3d1.css">
<link rel="preload" href="/assets/js/runtime~main.beb31cc3.js" as="script">
<link rel="preload" href="/assets/js/main.583cd0b0.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/nebula.svg" alt="Nebula Logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/nebula.svg" alt="Nebula Logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">Nebula Docs</b></a><a class="navbar__item navbar__link" href="/docs/intro">Tutorial</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/varchar-io/nebula" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT"></span></div><div class="react-toggle-track-x"><span class="toggle_71bT"></span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-list-page"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_2ahu thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_2hhb margin-bottom--md">Recent posts</div><ul class="sidebarItemList_2xAf"><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2021/04/01/custom_column">Custom Column - Instant UDF</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2021/03/01/expression_udf_udaf">Expression, UDF, and UDAF</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2021/02/01/sketch">Sketch: extensible customized aggregation</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2021/01/01/web_ui">Web UI</a></li><li class="sidebarItem_2UVv"><a class="sidebarItemLink_1RT6" href="/blog/2020/09/01/bigint">BigInt Problem</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_GeHD" itemprop="headline"><a itemprop="url" href="/blog/2021/04/01/custom_column">Custom Column - Instant UDF</a></h2><div class="blogPostData_291c margin-vert--md"><time datetime="2021-04-01T00:00:00.000Z" itemprop="datePublished">April 1, 2021</time> 路 3 min read</div></header><div class="markdown" itemprop="articleBody"><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="overview"></a>Overview<a class="hash-link" href="#overview" title="Direct link to heading">#</a></h2><p>Usually we saw data systems provide extensibility by allowing user to define functions - UDF, in Nebula, we allow user to define custom column instead, there are some reasons:</p><ul><li>custom column is simpler - for reuse purpose, user define functions and use function in transformation, there are more places to handle this customized behavior. Custom column allows us to sumply focus on extra column computing.</li><li>custom column is essential what user is looking for hence more straightforward. As mentioned above, most of time user defined function is for reuse purpose, however it is not a problem what Nebula tries to solve.</li><li>Nebula core problem here is to allow user to define transformation through literal language - <code>javascript</code>.</li><li>this aligns Nebula&#x27;s another goal to enable user to run simple distributed machine learning algorithm, custom column will be <code>feature extraction</code> in that use case.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="feature-support"></a>Feature Support<a class="hash-link" href="#feature-support" title="Direct link to heading">#</a></h2><p>Support custom column as extensibility used by Nebula in two scenarios, they are:</p><ul><li><p>Runtime compute - user provide custom column in query, and we compute this custom column value for it. In this scenario, column definition is logical, column value is computed on the fly by observers, no persistent required here hence this custom column is not included in the table schema definition.
for example: </p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">```</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // schema definition</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // table = ROW(a:int, b:long, c:string);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // custom column definition</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    const cc = () =&gt; nebula.column(&quot;a&quot;) * 2 + 3;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    nebula.register(&quot;cc&quot;, Types.INT, cc);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // use the custom column in query</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    table.select(&quot;cc&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">```</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li><li><p>Ingestion compute - user provides custom column hook in ingestion definition, it means original data source doesn&#x27;t have the column, but we define it by lambda. This new computed column during ingestion time will be persisted hence included in table schema.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#393A34"><span class="token plain">nebula.test:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    # max 10G RAM assigment</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    max-mb: 10000</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    # max 10 days assignment</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    max-hr: 240</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    schema: &quot;ROW&lt;id:int, price:double, price2:double&gt;&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    columns:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      id:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        bloom_filter: true</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      price2:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        expr: &quot;[price] * 2&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    time:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      type: static</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      # get it from linux by &quot;date +%s&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      value: 1565994194</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>  note that in this example, <code>[price]</code> is just a convenient expression, in runtime, it will be converted to a real function satifying a javascript function definition as <code>const price2 = () =&gt; nebula.column(&quot;price&quot;) * 2</code></p></li></ul><p>Internally, we&#x27;re supporting ES2015 syntax standard javascript expression, this should give users flexible enough space to transform data to whatever they want.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="more-to-expect"></a>More To Expect<a class="hash-link" href="#more-to-expect" title="Direct link to heading">#</a></h2><p>Nebula shall support custom aggregation column as well through <code>javascript</code> definition, however, it is a lot more work and we want to have a performant implementation of major aggregation functions, so this is not in the priority list for now.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_GeHD" itemprop="headline"><a itemprop="url" href="/blog/2021/03/01/expression_udf_udaf">Expression, UDF, and UDAF</a></h2><div class="blogPostData_291c margin-vert--md"><time datetime="2021-03-01T00:00:00.000Z" itemprop="datePublished">March 1, 2021</time> 路 3 min read</div></header><div class="markdown" itemprop="articleBody"><p><strong>Nebula</strong> analytics relies on aggregations, and these aggregations are expressed by</p><ul><li>Expressions: including constant ops, arthmetic ops, logical ops and column ops.
These operations are basics for a programing language, hence they are fundementals to nebula query engine.   </li><li>UDF: nebula will provide native UDFs in its own package implemented with native code.
We plan to add customized UDF through user interface which will be available in javascript. V8 engine will be used to execute them with interopability with Nebula runtime data strucutre.
Basic built-in UDFs are &quot;in&quot;, &quot;not in&quot;, &quot;like&quot;, &quot;ilike&quot;, etc.</li><li>UDAF: core analytic capability are supported by &quot;aggregation metrics by dimensions&quot;.
Nebula provides efficient implementations for them, UDAF like &quot;count&quot;, &quot;sum&quot;, &quot;avg&quot;, &quot;median&quot;, &quot;percentiles&quot;, &quot;NDV&quot; shall be available.</li></ul><p>Plug-in a new UDF / UDAF should be straigtforward in nebula code base, feel free to submit a new request through issue or PR. </p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="avg"></a>AVG<a class="hash-link" href="#avg" title="Direct link to heading">#</a></h2><p>UDAF &quot;avg&quot; is an interesting topic, I have been thinking a lot on how to implement it.
Basically there are two major approaches (well essentially the same concept)
1) Having SUM / COUNT columns in computing time and convert to AVG column at the last step.
In this approach, we flex the schema and operate in query level.
2) Have &quot;special&quot; column type such as a binary buffer or wider type like int128.
It is similar to number 1 in terms of flexing schema, but it doesn&#x27;t change column count.</p><p>I think #1 provides pretty generic solution for many similar problem - extend data store in runtime by adding more columns. #2 sounds a bit hacky, but because it maintains same width of schema, a lot of checks and type converts becoming naturely easy. So in the first try, I chose to implement AVG using #2 approach without changing much on the query planning itself.</p><p>A very important data structure used in Nebula is called &quot;HashFlat&quot;, it&#x27;s basically a row-based data set with hash function to keep unique rows in contingious memory block. It needs client to provide interfaces to process data in different type:</p><ul><li>Store:    convert UDAF inner expression value into the store type in hash flat.</li><li>Merge:    merge two rows with same keys.</li><li>Finalize: convert store type into desired type.</li></ul><p>A UDAF will define these 3 functions, and when a hash flat is setup, a wrapper of this function set will be provided.
So when HashFlat receives a duplicate rows (same keys), it will trigger the merge function, and new row to trigger store method, for most cases, since store type equals native type, it will have empty store and finalize method.
<img alt="UDF + Types" src="/assets/images/udf.types-60d1101e2b3972371056caf7d65642d2.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="percentiles-ndv-and-others"></a>Percentiles, NDV and others<a class="hash-link" href="#percentiles-ndv-and-others" title="Direct link to heading">#</a></h2><p>Follow the same pattern, for any UDAF that requires state management, it can go the same design as AVG using a store type for state management and use finalize method to convert temporary state to final value.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_GeHD" itemprop="headline"><a itemprop="url" href="/blog/2021/02/01/sketch">Sketch: extensible customized aggregation</a></h2><div class="blogPostData_291c margin-vert--md"><time datetime="2021-02-01T00:00:00.000Z" itemprop="datePublished">February 1, 2021</time> 路 5 min read</div></header><div class="markdown" itemprop="articleBody"><p>We need extensible model to support adding any customized data structure for special data aggregation.
It is challenge to make a decent design fitting into this requirements, let&#x27;s take a look at what current system</p><ul><li>UDAF/UDF are modeled as generic expressions which represented by ValueEval or TypeValueEval in the runtime.<ul><li>ValueEval is extensible as long as it is visible, it has methods &quot;eval&quot; for value evaluation, &quot;merge&quot; for value merging, &quot;stack&quot; for value accumulation between different types.</li><li>UDAF needs differentiate input type, runtime type and schema type so that it can finish aggregation life cycle.</li></ul></li><li>RowData interface is the generic interface used to exchange data between any compute layers.<ul><li>Expressions details are hidden by RowData interface which supports only readXXX methods for each individual supported types in our schema system.</li></ul></li><li>Sometimes it is not performant if we don&#x27;t expose &quot;input type&quot; to compute layer when customized type is involved. </li></ul><p>For example, if we&#x27;re building a TDigest sketch for given expression typed in integer, assuming we have TDigestUDAF which defined types</p><ul><li>input type: INTEGER</li><li>runtime type: TDigest Object modeled as &quot;void*&quot; or better std::shared_ptr&lt;Serializable&gt;</li><li>schema type: VARCHAR</li></ul><p>In computing time, when we iterate all rows, remember that the UDAF expression is hidden beind by a RowData interface which only allow a given column which contains the UDAF to expose one type, usually we expose runtime type, that means we only have RowData.readPointer(), the implication here is that we might end up with constructing/descruting huge number of TDigest objects, this doesn&#x27;t sound correct and definitely not scalable for &quot;customized&quot; sketch.</p><p><img alt="Where to put aggregation" src="/assets/images/sketch-364f2f00c3a6aefded1086b32559009d.png"></p><p>(External Compute: HB)</p><p>To overcome this hurdle, we have a few options to consider</p><ol><li>Expose UDAF as its inner expression, and leave its aggregation logic to external compute.<ol><li>e.g SUM(EXPR1) -&gt; EXPR1 through RowData interface</li><li>Sure, external compute will have enough metadata to understand how to invoke its logic for aggregation.</li><li>Pros &amp; Cons: very straightforward and leave data layer clean. The downside is the inconsistency in the schema, since most of the time, the UDAF result value type differs from its inner expression type.</li></ol></li><li>Expose different interface in RowData to allow external compute to fetch inner experssion value instead.<ol><li>This approach doesn&#x27;t change its current runtime schema.</li><li>Some kind of brokeness on RowData interface.</li><li>Difficult to manage life cycle of the custom object since UDAF itself creates object internally and pass to external compute to manage.</li></ol></li></ol><p>None of above approaches is ideal and it is difficult to sort out an ideal approach for now.
Here is what I propose to do to make this a bit cleaner hopefully:</p><ol><li>Mainly take approach 1 to keep UDAF interface clean and simple.</li><li>Push complexity into HB by introducing aggregator object for each defined UDAF.</li><li>The aggregator may or may not require extra object allocation, depends on if it needs assistant data structure.<ol><li>CreateObject</li><li>Aggregate</li><li>Serde</li></ol></li><li>We need to allow all UDAF to have different runtime schema but with final schema corrected in last stage.</li></ol><p>Hopefully this change will help boost performance as well, for example AVG. Since this is going to be large refactoring, I will leave it to next diff and report back what the result looks like - the basic measure is ensure AVG UDAF is working well/better in the new design.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="update"></a>Update<a class="hash-link" href="#update" title="Direct link to heading">#</a></h3><p>Through the whole Nebula code base, all the boundary is communicated through RowData and its cursor type RowCursor, it is extremely difficult to model a customized object (aggregator) on a plain storage wrapped by a RowData, and also to be very efficient to avoid object allocations across rows. I also looked at &quot;struct&quot; type, if we can reuse it to represent any customized sketch but attached with different functions, again it is good idea to keep RowData interface intact but facing two big challenges:</p><ol><li>construct sketch object on given memory chunk represented by the struct. (preventing object serde per row)</li><li>avoid object creation for non-aggregated rows. </li></ol><p>Given all the thoughts and exploration, I decided to make the change to RowData interface, adding a new interface to it to fetch aggregator object given column name/index.
Client will get a valid aggregator object if </p><ul><li>the row represents an aggregated row</li><li>the column is an aggregation column</li></ul><p>otherwise it will return a nullptr.</p><p>Aggregation column type will be the same as its inner expression type, so that we know if a ROW can return normal value to be aggregated or it can return aggregator to aggregate other incoming values in block computing phase.</p><p>In merge phase - aggregator will aggregate other aggregators.</p><p>In final phase - an aggregator will provide finalize method to return its desired value.</p><p>In the new architecture, any sketch is attached and can be detached. As optimization, it may share memory as schema indicates which is controlled by column width. If the column is an aggregation field, it will produce alignment space for the column no matter it has null value or not.</p><p>When serialization, sketch will be serialized into data space, and deserialization will be restruct the sketch for each aggregation column.</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_GeHD" itemprop="headline"><a itemprop="url" href="/blog/2021/01/01/web_ui">Web UI</a></h2><div class="blogPostData_291c margin-vert--md"><time datetime="2021-01-01T00:00:00.000Z" itemprop="datePublished">January 1, 2021</time> 路 3 min read</div></header><div class="markdown" itemprop="articleBody"><p>From service deployment perspective, there are 4 major components backs up <strong>Nebula</strong> service.
They are </p><ol><li>Nebula Server</li><li>Nebula Nodes</li><li>Nebula Service Gateway (Envoy)</li><li>Nebula Web</li></ol><p>Today these components are architectured in this way.
<img alt="Components V1" src="/assets/images/com_v1-e5463055b134abffda79f2d0035e277f.png"></p><p>In this mode, we&#x27;re opening Nebula raw service through envoy as service gateway which usually listens at some port for http traffic, itself maintains connection with Nebula service through HTTP2 (grpc).</p><p>Another open service is the web server which listens at standard 80 for browsers request, this service is backed by a NODE server (NodeJS). It serves static content and client logic for Nebula Web UI, this Web UI provides query interface for data analysis and graphics/charting functions for display. </p><p>Why do we architecture it in this way from beginning? Well, there are a few advantages by doing so:</p><ol><li>It maintains a lightweight web service for least amount of maintaince cost with high QPS for performance.</li><li>It sets up Web UI as a completely independant component which could be replaced by any tech stack or any new client for consuming the same service.</li><li>It provides complete UI/service separation for better maintainance. </li></ol><p>I appreciate this arch as it places decoupled design giving us best flexbility to make changes independently.</p><p>Now, I&#x27;m making a slight change for WEB-UI by routing service consumption behind web server. The reasons why I&#x27;m doing so are:</p><ul><li>Authentication. Due to isolation, we need to implement authentication in both interfaces (web + envoy) for single web client. By moving the service behind, we only need to maintain one for web only.</li><li>Security. This change doesn&#x27;t mean enovy doesn&#x27;t need authentication. We need to implement it anyways but not priority for now.</li></ul><p>After the change, th arch will look like this
<img alt="Components V2" src="/assets/images/com_v2-ae252b631a86f22c534a3a2d3229ea42.png"></p><p>The drawback of this change is obvious:</p><ol><li>for each query, it goes two hops rather than one (Q: client -&gt; web -&gt; (envoy -&gt; server) -&gt; web -&gt; client).
Given the extra hop happens in the same server for most of the cases, the impact should be minimal.</li><li>adding complexity of query/result transfer logic into web tier which is mostly doing translation.</li><li>Extra serde (JSON) from server replied object and web client.</li></ol><p>After this change, the envoy gateway is still open, but it will not consumed directly by web client.
Also note that, the pros/cons are clear for v1 vs v2, we want to make sure things are easy to switch back and forth. Currently it is supported by a variable <code>archMode</code> in web.js, we may move it to nebula config in future.</p><ul><li>archMode = 1 (v1): web client connect nebula server for query.</li><li>archMode = 2 (v2): web client connect web api as proxy for query.</li></ul><p>Cheers!</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_GeHD" itemprop="headline"><a itemprop="url" href="/blog/2020/09/01/bigint">BigInt Problem</a></h2><div class="blogPostData_291c margin-vert--md"><time datetime="2020-09-01T00:00:00.000Z" itemprop="datePublished">September 1, 2020</time> 路 3 min read</div></header><div class="markdown" itemprop="articleBody"><p>We know that Javascript can only represent 2^53-1 as it max number. For any values larger than that will lose precision during data exchange in javascript runtime. Most of the time, we have to pay cost to serializing 64bits in string format.</p><p>Nebula faces this issue too, in this short note, I would just like to summarize all places with the concern and how we handle them for now, this doesn&#x27;t mean it is ideal, in fact, we are still looking for improvements. </p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="no-1-rapidjson"></a>No 1. rapidjson<a class="hash-link" href="#no-1-rapidjson" title="Direct link to heading">#</a></h2><p>We have been using RapidJson as the JSON serde library in our C++ runtime, due to its capability handling this concern well.
We don&#x27;t do <code>long&lt;--&gt;string</code> conversion trick. Hence we removed similar trick in your code base, specifically in InExpression serde code path.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="no-2-nodejs"></a>No 2. node.js<a class="hash-link" href="#no-2-nodejs" title="Direct link to heading">#</a></h2><p>node.js is the web server runtime <code>Nebula Web</code> resides in, it is definitely the most hot place regarding this issue. We have been using JSON as data fromat to exchange requests/responses between <code>web client</code> and <code>Nebula Server</code>.  Here are what we have done:</p><ol><li>We&#x27;re using json-bigint package to do <code>json.parse</code> so if the input JSON includes bigint values, it won&#x27;t lose the value&#x27;re precision.</li><li>In nebula proto, we added two more types of predicate, so it allows client to use one of them<ol><li>value: string type </li><li>nvalue: int64 type</li><li>dvalue: double type.</li></ol></li></ol><p>with this change, we don&#x27;t pay string-&gt;int or string-&gt;double type data conversion. (In fact, protobuf does this for us - it is uncertain if perf is better, but at least cleaner at interface).</p><p>The serde work is dene by protobuf-js, which is still using <code>Number</code> for all number values, so the problem still exists, if passing bigint value in <code>grpc</code> call defined by int64 in <code>nebula.proto</code>, Nebula Server may receive wrong value. And I haven&#x27;t seen this is going to be fixed soon anywhere. We will keep eyes open for any alternative solution.</p><p>As a work-around, we will use &quot;string&quot; representation for <code>nvalue</code> by appending <code>[jstype = JS_STRING]</code> in its proto declaration. After that, we requires client to send string list for this field for now. Definitely this is neither convinient nor efficient.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="no-3-web"></a>No 3. web<a class="hash-link" href="#no-3-web" title="Direct link to heading">#</a></h2><p>In <code>Nebula UI</code> which means browser here, we haven&#x27;t handle any thing like this, since it is for display purpose, basically all bigint values are returned in <code>string</code> type. Client code (browser js) needs to convert it if used in further computation.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="no-4-other-clients"></a>No 4. other clients.<a class="hash-link" href="#no-4-other-clients" title="Direct link to heading">#</a></h2><p>This is obvious but just to mention, other clients that is not executing in javascript runtime should not have this issue, for example, if I use <code>curl</code> to post a JSON blob of bigint array, <code>Nebula API</code> (node.js) won&#x27;t lose precision of values. Other clients like Java should be fine too.</p></div></article><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></main></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://discord.gg/nmZsXC53" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://twitter.com/varchario" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/varchar-io/nebula" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright 漏 2021 Columns AI, Inc.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.beb31cc3.js"></script>
<script src="/assets/js/main.583cd0b0.js"></script>
</body>
</html>